# 设计模式

## 关系图
![image](https://user-images.githubusercontent.com/80819421/143391457-523b0ddc-dcbc-4eb9-ba56-31a568a1e5c4.png)

## 七大原则

### 开闭原则
```java
当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求
```

![image](https://user-images.githubusercontent.com/80819421/143391517-ccde7586-bfca-47df-9e40-dbf70361f562.png)

### 里氏替换原则
```java
子类可以扩展父类的功能，但不能改变父类原有的功能。
```

![image](https://user-images.githubusercontent.com/80819421/143391591-017f6550-edfd-4127-ad8b-47e673b86aab.png)

### 依赖倒置原则
```java
依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合；
依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性
```

![image](https://user-images.githubusercontent.com/80819421/143391658-5472174c-025e-4914-9a26-978d8ec407ae.png)

### 单一职责原则
```java
一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
```

![image](https://user-images.githubusercontent.com/80819421/143391726-637e10c4-6106-402b-9cc6-6d94e92bdc27.png)

### 接口隔离原则
```java
一个类对另一个类的依赖应该建立在最小的接口上，即要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
```

![image](https://user-images.githubusercontent.com/80819421/143391768-eba2af42-db78-491e-a780-7256a28a5856.png)

### 迪米特法则
```java
如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性；
即当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
```

![image](https://user-images.githubusercontent.com/80819421/143391792-47605a43-808f-4838-aa32-b1e28f69f692.png)

### 合成复用原则
```java
要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现
```

![image](https://user-images.githubusercontent.com/80819421/143392269-a1339925-95bd-4117-9abf-d779c1263abb.png)
![image](https://user-images.githubusercontent.com/80819421/143392307-d20ee3ee-4f01-4c5b-b57e-b26acc2a3d64.png)


### 总结软件开发七大原则：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。即降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。

## 设计模式

### 创建型模式
```java
单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。只有工厂方法属于类创建模式，其他属于对象创建模式
抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
```
![image](https://user-images.githubusercontent.com/80819421/143517641-72b7dd5a-c84a-4bcb-8f30-35ea91978fbf.png)
![image](https://user-images.githubusercontent.com/80819421/143518392-0989e0be-917a-4c44-b49d-b3ad94b6c04f.png)
![image](https://user-images.githubusercontent.com/80819421/143518915-61fd21ae-0db1-4de2-80b2-6c62aabb37f8.png)
![image](https://user-images.githubusercontent.com/80819421/143518969-d7b00ba7-d785-4dd9-afa1-0a476d0d1f99.png)
![image](https://user-images.githubusercontent.com/80819421/143519130-6a6ea5ae-1903-45f3-9c39-e432e8461257.png)

### 建造者模式
```java
主要角色：
产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。
```
![image](https://user-images.githubusercontent.com/80819421/143519521-ee901b61-6e25-4e6a-bc6c-c80184a624f3.png)

